<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melting Time Dimes</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Mystery+Quest&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Mystery Quest', cursive;
            background: linear-gradient(45deg, #2c1810, #8b4513, #daa520);
            background-size: 400% 400%;
            animation: dreamscape 8s ease-in-out infinite;
            overflow: hidden;
            height: 100vh;
        }
        
        @keyframes dreamscape {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4, #45b7d1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: loadingGradient 3s ease-in-out infinite;
        }
        
        @keyframes loadingGradient {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }
        
        .melting-clock {
            width: 120px;
            height: 80px;
            background: #ffd700;
            border-radius: 50% 50% 80% 20%;
            position: relative;
            animation: melt 2s ease-in-out infinite;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        @keyframes melt {
            0%, 100% { transform: scaleY(1) skewX(0deg); }
            50% { transform: scaleY(0.7) skewX(-15deg); }
        }
        
        .clock-face {
            position: absolute;
            top: 10px;
            left: 20px;
            width: 40px;
            height: 40px;
            border: 3px solid #8b4513;
            border-radius: 50%;
            background: white;
        }
        
        .loading-text {
            color: white;
            font-size: 2em;
            margin-top: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: float 2s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: none;
        }
        
        .game-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            color: #ffd700;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .score-info {
            display: flex;
            gap: 30px;
            font-size: 1.2em;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        .game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .player-dime {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b);
            border-radius: 50%;
            border: 3px solid #8b4513;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            transition: all 0.1s ease;
            z-index: 50;
        }
        
        .player-dime::before {
            content: 'Â¢';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #8b4513;
        }
        
        .obstacle {
            position: absolute;
            background: linear-gradient(45deg, #ff4757, #ff3838);
            border-radius: 50% 50% 80% 20%;
            animation: meltObstacle 3s ease-in-out infinite;
            box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4);
        }
        
        @keyframes meltObstacle {
            0%, 100% { transform: scaleY(1) rotate(0deg); }
            50% { transform: scaleY(0.8) rotate(5deg); }
        }
        
        .collectible {
            position: absolute;
            width: 25px;
            height: 25px;
            background: radial-gradient(circle, #4ecdc4, #26d0ce);
            border-radius: 50%;
            animation: shimmer 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.8);
        }
        
        @keyframes shimmer {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: white;
            max-width: 500px;
            margin: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: modalFloat 3s ease-in-out infinite;
        }
        
        @keyframes modalFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(1deg); }
        }
        
        .modal h2 {
            font-family: 'Creepster', cursive;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .instructions {
            text-align: left;
            margin: 20px 0;
            line-height: 1.6;
        }
        
        .instructions li {
            margin: 10px 0;
        }
        
        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,107,107,0.9), rgba(78,205,196,0.9));
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        
        .game-over-content {
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            animation: gameOverPulse 2s ease-in-out infinite;
        }
        
        @keyframes gameOverPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .level-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff9a9e, #fecfef, #fecfef, #ff9a9e);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 175;
            animation: transitionSwirl 1s ease-in-out;
        }
        
        @keyframes transitionSwirl {
            0% { transform: rotate(0deg) scale(0); }
            100% { transform: rotate(360deg) scale(1); }
        }
        
        .floating-text {
            position: absolute;
            color: #ffd700;
            font-weight: bold;
            font-size: 1.5em;
            animation: floatUp 2s ease-out forwards;
            z-index: 75;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0px); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .game-header {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }
            
            .score-info {
                gap: 15px;
                font-size: 1em;
            }
            
            .modal-content {
                padding: 20px;
                margin: 10px;
            }
            
            .player-dime {
                width: 35px;
                height: 35px;
            }
        }
        
        /* Touch controls for mobile */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 20px;
            z-index: 100;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.8);
            border: none;
            color: #8b4513;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="melting-clock">
            <div class="clock-face"></div>
        </div>
        <div class="loading-text">Loading Surreal Dreams...</div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="gameContainer">
        <!-- Game Header -->
        <div class="game-header">
            <div class="score-info">
                <div>Score: <span id="score">0</span></div>
                <div>Level: <span id="level">1</span></div>
                <div>Lives: <span id="lives">3</span></div>
                <div>High Score: <span id="highScore">0</span></div>
            </div>
            <div class="controls">
                <button class="btn" id="muteBtn">ðŸ”Š</button>
                <button class="btn" id="howToPlayBtn">?</button>
                <button class="btn" id="restartBtn">âŸ²</button>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas class="game-canvas" id="gameCanvas"></canvas>
        
        <!-- Player Dime -->
        <div class="player-dime" id="playerDime"></div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <button class="mobile-btn" id="leftBtn">â—€</button>
            <button class="mobile-btn" id="rightBtn">â–¶</button>
            <button class="mobile-btn" id="jumpBtn">â†‘</button>
        </div>
    </div>

    <!-- How to Play Modal -->
    <div class="modal" id="howToPlayModal">
        <div class="modal-content">
            <h2>How to Play</h2>
            <ul class="instructions">
                <li><strong>Move:</strong> Use arrow keys or WASD to navigate your dime</li>
                <li><strong>Goal:</strong> Collect blue time fragments while avoiding red melting obstacles</li>
                <li><strong>Scoring:</strong> Each fragment = 10 points, level completion = 50 points</li>
                <li><strong>Lives:</strong> You start with 3 lives. Losing a life sends you back one level</li>
                <li><strong>Progression:</strong> Each level increases speed and adds more obstacles</li>
                <li><strong>Mobile:</strong> Use on-screen buttons on mobile devices</li>
            </ul>
            <button class="btn" id="startGameBtn">Start Playing</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-content">
            <h2 style="font-family: 'Creepster', cursive; font-size: 2.5em; margin-bottom: 20px;">Time Melted Away!</h2>
            <p style="font-size: 1.3em; margin: 15px 0;">Final Score: <span id="finalScore">0</span></p>
            <p style="font-size: 1.1em; margin: 15px 0;">Level Reached: <span id="finalLevel">1</span></p>
            <button class="btn" id="playAgainBtn" style="font-size: 1.2em; padding: 12px 24px; margin-top: 20px;">Play Again</button>
        </div>
    </div>

    <!-- Level Transition -->
    <div class="level-transition" id="levelTransition">
        <div style="text-align: center; color: white;">
            <h2 style="font-family: 'Creepster', cursive; font-size: 3em; margin-bottom: 20px;">Level <span id="transitionLevel">2</span></h2>
            <p style="font-size: 1.5em;">Reality Distorts Further...</p>
        </div>
    </div>

    <script>
        class MeltingTimeDimes {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.playerDime = document.getElementById('playerDime');
                
                // Game state
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.highScore = localStorage.getItem('meltingDimesHighScore') || 0;
                this.gameRunning = false;
                this.muted = false;
                
                // Player properties
                this.player = {
                    x: 100,
                    y: 300,
                    width: 40,
                    height: 40,
                    velocityX: 0,
                    velocityY: 0,
                    speed: 5,
                    jumpPower: 15,
                    onGround: false
                };
                
                // Game objects
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                
                // Game settings
                this.gravity = 0.8;
                this.groundY = 0;
                
                this.setupCanvas();
                this.bindEvents();
                this.loadAudio();
                this.showLoading();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.groundY = this.canvas.height - 100;
                
                // Update player position if needed
                if (this.player.y > this.groundY - this.player.height) {
                    this.player.y = this.groundY - this.player.height;
                }
            }
            
            bindEvents() {
                // Keyboard controls
                this.keys = {};
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Mobile controls
                document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['a'] = true;
                });
                document.getElementById('leftBtn').addEventListener('touchend', () => {
                    this.keys['a'] = false;
                });
                
                document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['d'] = true;
                });
                document.getElementById('rightBtn').addEventListener('touchend', () => {
                    this.keys['d'] = false;
                });
                
                document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['w'] = true;
                });
                document.getElementById('jumpBtn').addEventListener('touchend', () => {
                    this.keys['w'] = false;
                });
                
                // UI buttons
                document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                document.getElementById('howToPlayBtn').addEventListener('click', () => this.showModal('howToPlayModal'));
                document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
                document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
                document.getElementById('playAgainBtn').addEventListener('click', () => this.restartGame());
                
                // Modal close
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('modal')) {
                        e.target.style.display = 'none';
                    }
                });
            }
            
            loadAudio() {
                // Audio context for sound effects
                this.audioContext = null;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            playSound(frequency, duration, type = 'sine') {
                if (!this.audioContext || this.muted) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            showLoading() {
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    this.showModal('howToPlayModal');
                }, 3000);
            }
            
            showModal(modalId) {
                document.getElementById(modalId).style.display = 'flex';
            }
            
            hideModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }
            
            startGame() {
                this.hideModal('howToPlayModal');
                document.getElementById('gameContainer').style.display = 'block';
                this.resetGame();
                this.gameRunning = true;
                this.gameLoop();
            }
            
            resetGame() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.player.x = 100;
                this.player.y = this.groundY - this.player.height;
                this.player.velocityX = 0;
                this.player.velocityY = 0;
                this.obstacles = [];
                this.collectibles = [];
                this.particles = [];
                this.updateUI();
                this.spawnLevel();
            }
            
            restartGame() {
                this.hideModal('gameOverScreen');
                this.resetGame();
                this.gameRunning = true;
            }
            
            spawnLevel() {
                this.obstacles = [];
                this.collectibles = [];
                
                // Spawn obstacles based on level
                const obstacleCount = Math.min(3 + this.level, 10);
                for (let i = 0; i < obstacleCount; i++) {
                    this.obstacles.push({
                        x: 300 + i * (this.canvas.width / obstacleCount) + Math.random() * 100,
                        y: this.groundY - 60 - Math.random() * 200,
                        width: 40 + Math.random() * 20,
                        height: 60 + Math.random() * 40,
                        speed: 1 + this.level * 0.3,
                        direction: Math.random() > 0.5 ? 1 : -1
                    });
                }
                
                // Spawn collectibles
                const collectibleCount = Math.min(5 + this.level, 15);
                for (let i = 0; i < collectibleCount; i++) {
                    this.collectibles.push({
                        x: 200 + i * (this.canvas.width / collectibleCount) + Math.random() * 50,
                        y: this.groundY - 100 - Math.random() * 300,
                        width: 25,
                        height: 25,
                        collected: false,
                        bobOffset: Math.random() * Math.PI * 2
                    });
                }
            }
            
            updatePlayer() {
                // Handle input
                if (this.keys['a'] || this.keys['arrowleft']) {
                    this.player.velocityX = -this.player.speed;
                } else if (this.keys['d'] || this.keys['arrowright']) {
                    this.player.velocityX = this.player.speed;
                } else {
                    this.player.velocityX *= 0.8; // Friction
                }
                
                // Jumping
                if ((this.keys['w'] || this.keys['arrowup'] || this.keys[' ']) && this.player.onGround) {
                    this.player.velocityY = -this.player.jumpPower;
                    this.player.onGround = false;
                    this.playSound(400, 0.1);
                }
                
                // Apply gravity
                this.player.velocityY += this.gravity;
                
                // Update position
                this.player.x += this.player.velocityX;
                this.player.y += this.player.velocityY;
                
                // Ground collision
                if (this.player.y > this.groundY - this.player.height) {
                    this.player.y = this.groundY - this.player.height;
                    this.player.velocityY = 0;
                    this.player.onGround = true;
                }
                
                // Screen boundaries
                if (this.player.x < 0) this.player.x = 0;
                if (this.player.x > this.canvas.width - this.player.width) {
                    this.player.x = this.canvas.width - this.player.width;
                }
                
                // Update DOM element position
                this.playerDime.style.left = this.player.x + 'px';
                this.playerDime.style.top = this.player.y + 'px';
            }
            
            updateObstacles() {
                this.obstacles.forEach(obstacle => {
                    obstacle.x += obstacle.speed * obstacle.direction;
                    
                    // Bounce off screen edges
                    if (obstacle.x <= 0 || obstacle.x >= this.canvas.width - obstacle.width) {
                        obstacle.direction *= -1;
                    }
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, obstacle)) {
                        this.loseLife();
                    }
                });
            }
            
            updateCollectibles() {
                this.collectibles.forEach((collectible, index) => {
                    // Bobbing animation
                    collectible.bobOffset += 0.1;
                    collectible.currentY = collectible.y + Math.sin(collectible.bobOffset) * 10;
                    
                    // Check collection
                    if (!collectible.collected && this.checkCollision(this.player, {
                        x: collectible.x,
                        y: collectible.currentY,
                        width: collectible.width,
                        height: collectible.height
                    })) {
                        collectible.collected = true;
                        this.score += 10;
                        this.playSound(600, 0.2);
                        this.createParticles(collectible.x, collectible.currentY);
                        this.showFloatingText('+10', collectible.x, collectible.currentY);
                    }
                });
                
                // Remove collected items
                this.collectibles = this.collectibles.filter(c => !c.collected);
                
                // Check level completion
                if (this.collectibles.length === 0) {
                    this.nextLevel();
                }
            }
            
            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.velocityX;
                    particle.y += particle.velocityY;
                    particle.velocityY += 0.2; // Gravity
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            createParticles(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + 12,
                        y: y + 12,
                        velocityX: (Math.random() - 0.5) * 10,
                        velocityY: Math.random() * -8 - 2,
                        life: 30,
                        color: `hsl(${Math.random() * 60 + 180}, 100%, 60%)`
                    });
                }
            }
            
            showFloatingText(text, x, y) {
                const floatingText = document.createElement('div');
                floatingText.className = 'floating-text';
                floatingText.textContent = text;
                floatingText.style.left = x + 'px';
                floatingText.style.top = y + 'px';
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    document.body.removeChild(floatingText);
                }, 2000);
            }
            
            loseLife() {
                this.lives--;
                this.playSound(200, 0.5, 'sawtooth');
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Go back one level (but not below 1)
                    if (this.level > 1) {
                        this.level--;
                    }
                    this.restartLevel();
                }
            }
            
            restartLevel() {
                this.player.x = 100;
                this.player.y = this.groundY - this.player.height;
                this.player.velocityX = 0;
                this.player.velocityY = 0;
                this.spawnLevel();
                this.updateUI();
            }
            
            nextLevel() {
                this.level++;
                this.score += 50; // Level completion bonus
                this.playSound(800, 0.3);
                
                // Show level transition
                document.getElementById('transitionLevel').textContent = this.level;
                document.getElementById('levelTransition').style.display = 'flex';
                
                setTimeout(() => {
                    document.getElementById('levelTransition').style.display = 'none';
                    this.spawnLevel();
                }, 1000);
            }
            
            gameOver() {
                this.gameRunning = false;
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('meltingDimesHighScore', this.highScore);
                }
                
                // Show game over screen
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
            
            toggleMute() {
                this.muted = !this.muted;
                document.getElementById('muteBtn').textContent = this.muted ? 'ðŸ”‡' : 'ðŸ”Š';
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('highScore').textContent = this.highScore;
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Create surreal background gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                const hue = (Date.now() * 0.01 + this.level * 30) % 360;
                gradient.addColorStop(0, `hsl(${hue}, 60%, 20%)`);
                gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 40%, 40%)`);
                gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 80%, 60%)`);
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw floating shapes in background
                this.drawFloatingShapes();
                
                // Draw ground
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(0, this.groundY, this.canvas.width, this.canvas.height - this.groundY);
                
                // Add ground texture
                this.ctx.fillStyle = '#654321';
                for (let i = 0; i < this.canvas.width; i += 20) {
                    this.ctx.fillRect(i, this.groundY + 10, 10, 5);
                }
                
                // Draw obstacles (melting shapes)
                this.obstacles.forEach(obstacle => {
                    this.drawMeltingObstacle(obstacle);
                });
                
                // Draw collectibles
                this.collectibles.forEach(collectible => {
                    if (!collectible.collected) {
                        this.drawCollectible(collectible);
                    }
                });
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.life / 30;
                    this.ctx.fillRect(particle.x, particle.y, 4, 4);
                    this.ctx.globalAlpha = 1;
                });
                
                // Draw surreal elements
                this.drawSurrealElements();
            }
            
            drawFloatingShapes() {
                const time = Date.now() * 0.001;
                
                // Floating clocks
                for (let i = 0; i < 3; i++) {
                    const x = (this.canvas.width * 0.2) + i * (this.canvas.width * 0.3) + Math.sin(time + i) * 50;
                    const y = 50 + Math.cos(time * 0.7 + i) * 30;
                    this.drawFloatingClock(x, y, 30 + Math.sin(time + i) * 10);
                }
                
                // Abstract floating shapes
                for (let i = 0; i < 5; i++) {
                    const x = (i * this.canvas.width / 5) + Math.sin(time * 0.5 + i) * 100;
                    const y = 100 + Math.cos(time * 0.3 + i) * 80;
                    this.drawAbstractShape(x, y, i);
                }
            }
            
            drawFloatingClock(x, y, size) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(Math.sin(Date.now() * 0.001) * 0.3);
                
                // Melting clock body
                this.ctx.fillStyle = '#ffd700';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, size, size * 0.7, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Clock face
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(0, -size * 0.2, size * 0.6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Clock hands
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -size * 0.2);
                this.ctx.lineTo(0, -size * 0.5);
                this.ctx.moveTo(0, -size * 0.2);
                this.ctx.lineTo(size * 0.3, -size * 0.2);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            drawAbstractShape(x, y, index) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(Date.now() * 0.0005 * (index + 1));
                
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b'];
                this.ctx.fillStyle = colors[index % colors.length];
                this.ctx.globalAlpha = 0.3;
                
                // Draw distorted shape
                this.ctx.beginPath();
                const points = 6;
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const radius = 20 + Math.sin(Date.now() * 0.003 + i) * 10;
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        this.ctx.moveTo(px, py);
                    } else {
                        this.ctx.lineTo(px, py);
                    }
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawMeltingObstacle(obstacle) {
                this.ctx.save();
                this.ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                
                // Melting effect
                const meltFactor = Math.sin(Date.now() * 0.003) * 0.3 + 1;
                this.ctx.scale(1, meltFactor);
                this.ctx.rotate(Math.sin(Date.now() * 0.002) * 0.1);
                
                // Gradient fill
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, obstacle.width);
                gradient.addColorStop(0, '#ff4757');
                gradient.addColorStop(1, '#ff3838');
                this.ctx.fillStyle = gradient;
                
                // Draw melting shape
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add drip effect
                this.ctx.fillStyle = '#ff2828';
                this.ctx.beginPath();
                this.ctx.ellipse(0, obstacle.height / 3, obstacle.width / 6, obstacle.height / 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawCollectible(collectible) {
                const x = collectible.x + collectible.width / 2;
                const y = collectible.currentY + collectible.height / 2;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(Date.now() * 0.005);
                
                // Glowing effect
                this.ctx.shadowColor = '#4ecdc4';
                this.ctx.shadowBlur = 15;
                
                // Main body
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, collectible.width);
                gradient.addColorStop(0, '#4ecdc4');
                gradient.addColorStop(1, '#26d0ce');
                this.ctx.fillStyle = gradient;
                
                this.ctx.beginPath();
                this.ctx.arc(0, 0, collectible.width / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Inner sparkle
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(-5, -5, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            drawSurrealElements() {
                // Draw elongated shadows
                const time = Date.now() * 0.001;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                
                // Shadow from player
                const shadowLength = 100 + Math.sin(time) * 50;
                this.ctx.beginPath();
                this.ctx.ellipse(
                    this.player.x + this.player.width / 2 + shadowLength,
                    this.groundY + 10,
                    shadowLength / 3,
                    10,
                    Math.PI / 6,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Distant melting horizon line
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let x = 0; x < this.canvas.width; x += 10) {
                    const y = this.canvas.height * 0.3 + Math.sin(x * 0.01 + time) * 20;
                    if (x === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }
            
            gameLoop() {
                if (!this.gameRunning) return;
                
                this.updatePlayer();
                this.updateObstacles();
                this.updateCollectibles();
                this.updateParticles();
                this.updateUI();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('load', () => {
            new MeltingTimeDimes();
        });
    </script>
</body>
</html>
